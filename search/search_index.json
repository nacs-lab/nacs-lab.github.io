{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Hardware Outputs The Ni lab computer control system is a flexible control system for controlling all the key components of an AMO Physics experiment. The key categories of control signals include RF outputs , Analog outputs and Digital outputs . RF outputs : These are output signals with a certain frequency (typically tens to hundreds of MHz) and an amplitude. They are used mostly for driving acousto-optic/electro-optic modulators and providing reference RF signals for laser locking. Analog outputs : These are relatively low frequency output signals (one update every 2 to 2.5 microseconds) that can take arbitrary shapes in time. They are used as control signals for various PID control circuits in the lab including those that stabilize the current through magnetic field coils or laser intensity. Analog outputs (faster) : This is in its own category, since it utilizes its own device, which is an arbitrary waveform generator. The AWG updates so that one sample can be output every 1.6 ns or even faster. We use this for creating multiple tweezers (i.e. generating multiple RF tones at once). Digital outputs : These are signals that take two discrete values, low and high. They are used for interfacing with external hardware including the triggering of external function generators, scientific cameras, laser shutters or controlling the route of RF signals. When setting up a new piece of equipment in the lab, utilizing these existing RF, analog and digital outputs (usually digital) are the easiest ways to get started quickly! Note that our FPGA is the master time reference for the entire sequence. It directly interfaces with RF outputs (Analog Devices DDS chips) with physical connections and also directly provides the TTL outputs. It clocks our slow analog output (National Instruments DAC card) and also provides the start trigger for our fast analog output (Spectrum Instrumentation AWG) Control Software For the purpose of control, we require a flexible and easy-to-use system. Our main goals are to allow the user to do anything they can think of, and also allow the more curious to explore and add new devices and functionality as easily as possible without compromising quality. To this end, here is a non-exhaustive list of features and design considerations of our system Script-based frontend: We use a script-based frontend (currently MATLAB) for constructing and running sequences. Scripts can take advantage of all the features of a given programming language, especially control flow logic. For instance, it is easy to write loops and also conditional statements. It is easy to incorporate other software and also to interweave with analysis code and use for feedback. A graphical interface can be built on top of the script interface. Sequence compilation: After creation of a sequence, the sequence is compiled to a device-independent intermediate representation, doing as much work as possible before running the sequence. This includes compiling any ramp functions that are used in the experiment. Device abstraction: The device-independent intermediate representation of the sequence can then be used in a device-specific implementation. These device classes implement what should be done during a sequence run or what is done prior to a sequence being run. Thus, adding a new device to the control system on the control software side simply requires following this template. Web-based control interface: Our control suite includes a web-based control interface, where currently our digital and RF outputs can be flipped on and off and parameters changed. Our web-based control interface has a simple API to communicate independently (from our sequence runner) with devices, making new device additions straightforward. Flexible parameter scanning: Our sequence construction API allows for easily scannable parameters in various configurations (one can scan multiple parameters together, or across different dimensions). Default values are also supported to allow for easily testing parameters, while keeping default parameters to use if no change is needed. Dynamic in-sequence variables: Steps in a sequence can be controlled by dynamic variables which can be changed at the millisecond timescale. These dynamic variables represent all concepts including the time, amplitude or even ramp type of a pulse. These dynamic variables are changed during atom rearrangement. More details about this entire system can be found elsewhere on this guide, but hopefully this will get you started thinking about the requirements of our control system and the features we support What actually happens when you run a sequence? Let's follow the \"lifespan\" of a sequence from the time you hit the run button (or more appropriately run the run function). First, the MATLAB sequence will be serialized into a string of bytes that will then be reconstructed into a different representation in C++ (via Python). The C++ version of the sequence will then be further processed and compiled, ultimately into a list of \"abstract commands\" for all devices. It is up to each device to define what an abstract command means and how an abstract command should be interpreted. For instance, for the FPGA, these commands consist of setting a DDS amplitude, frequency or phase as well as changing a TTL output. For the slow analog output, we simply give the device a list of values to set. For the AWG, commands change the amplitude, frequency and phase of a particular RF tone being generated by the FPGA. These \"abstract commands\" are abstract in the sense that their actual values may be changed by the so-called dynamic in-sequence variables in the previous section . During the actual sequence, after the dynamic in-sequence variables are determined, \"actual commands\" (once again determined independently by each device) are created and sent off to each device to prepare to run. Then, once all devices are ready to go, the FPGA is told to run and the sequence is now run.","title":"Home"},{"location":"#overview","text":"","title":"Overview"},{"location":"#hardware-outputs","text":"The Ni lab computer control system is a flexible control system for controlling all the key components of an AMO Physics experiment. The key categories of control signals include RF outputs , Analog outputs and Digital outputs . RF outputs : These are output signals with a certain frequency (typically tens to hundreds of MHz) and an amplitude. They are used mostly for driving acousto-optic/electro-optic modulators and providing reference RF signals for laser locking. Analog outputs : These are relatively low frequency output signals (one update every 2 to 2.5 microseconds) that can take arbitrary shapes in time. They are used as control signals for various PID control circuits in the lab including those that stabilize the current through magnetic field coils or laser intensity. Analog outputs (faster) : This is in its own category, since it utilizes its own device, which is an arbitrary waveform generator. The AWG updates so that one sample can be output every 1.6 ns or even faster. We use this for creating multiple tweezers (i.e. generating multiple RF tones at once). Digital outputs : These are signals that take two discrete values, low and high. They are used for interfacing with external hardware including the triggering of external function generators, scientific cameras, laser shutters or controlling the route of RF signals. When setting up a new piece of equipment in the lab, utilizing these existing RF, analog and digital outputs (usually digital) are the easiest ways to get started quickly! Note that our FPGA is the master time reference for the entire sequence. It directly interfaces with RF outputs (Analog Devices DDS chips) with physical connections and also directly provides the TTL outputs. It clocks our slow analog output (National Instruments DAC card) and also provides the start trigger for our fast analog output (Spectrum Instrumentation AWG)","title":"Hardware Outputs"},{"location":"#control-software","text":"For the purpose of control, we require a flexible and easy-to-use system. Our main goals are to allow the user to do anything they can think of, and also allow the more curious to explore and add new devices and functionality as easily as possible without compromising quality. To this end, here is a non-exhaustive list of features and design considerations of our system Script-based frontend: We use a script-based frontend (currently MATLAB) for constructing and running sequences. Scripts can take advantage of all the features of a given programming language, especially control flow logic. For instance, it is easy to write loops and also conditional statements. It is easy to incorporate other software and also to interweave with analysis code and use for feedback. A graphical interface can be built on top of the script interface. Sequence compilation: After creation of a sequence, the sequence is compiled to a device-independent intermediate representation, doing as much work as possible before running the sequence. This includes compiling any ramp functions that are used in the experiment. Device abstraction: The device-independent intermediate representation of the sequence can then be used in a device-specific implementation. These device classes implement what should be done during a sequence run or what is done prior to a sequence being run. Thus, adding a new device to the control system on the control software side simply requires following this template. Web-based control interface: Our control suite includes a web-based control interface, where currently our digital and RF outputs can be flipped on and off and parameters changed. Our web-based control interface has a simple API to communicate independently (from our sequence runner) with devices, making new device additions straightforward. Flexible parameter scanning: Our sequence construction API allows for easily scannable parameters in various configurations (one can scan multiple parameters together, or across different dimensions). Default values are also supported to allow for easily testing parameters, while keeping default parameters to use if no change is needed. Dynamic in-sequence variables: Steps in a sequence can be controlled by dynamic variables which can be changed at the millisecond timescale. These dynamic variables represent all concepts including the time, amplitude or even ramp type of a pulse. These dynamic variables are changed during atom rearrangement. More details about this entire system can be found elsewhere on this guide, but hopefully this will get you started thinking about the requirements of our control system and the features we support","title":"Control Software"},{"location":"#what-actually-happens-when-you-run-a-sequence","text":"Let's follow the \"lifespan\" of a sequence from the time you hit the run button (or more appropriately run the run function). First, the MATLAB sequence will be serialized into a string of bytes that will then be reconstructed into a different representation in C++ (via Python). The C++ version of the sequence will then be further processed and compiled, ultimately into a list of \"abstract commands\" for all devices. It is up to each device to define what an abstract command means and how an abstract command should be interpreted. For instance, for the FPGA, these commands consist of setting a DDS amplitude, frequency or phase as well as changing a TTL output. For the slow analog output, we simply give the device a list of values to set. For the AWG, commands change the amplitude, frequency and phase of a particular RF tone being generated by the FPGA. These \"abstract commands\" are abstract in the sense that their actual values may be changed by the so-called dynamic in-sequence variables in the previous section . During the actual sequence, after the dynamic in-sequence variables are determined, \"actual commands\" (once again determined independently by each device) are created and sent off to each device to prepare to run. Then, once all devices are ready to go, the FPGA is told to run and the sequence is now run.","title":"What actually happens when you run a sequence?"},{"location":"MathJax/","text":"MathJax Beautiful math in all browsers MathJax is an open-source JavaScript display engine for LaTeX, MathML, and AsciiMath notation that works in all modern browsers. It was designed with the goal of consolidating the recent advances in web technologies into a single, definitive, math-on-the-web platform supporting the major browsers and operating systems. It requires no setup on the part of the user (no plugins to download or software to install), so the page author can write web documents that include mathematics and be confident that users will be able to view it naturally and easily. Simply include MathJax and some mathematics in a web page, and MathJax does the rest. Some of the main features of MathJax include: High-quality display of LaTeX, MathML, and AsciiMath notation in HTML pages Supported in most browsers with no plug-ins, extra fonts, or special setup for the reader Easy for authors, flexible for publishers, extensible for developers Supports math accessibility, cut-and-paste interoperability, and other advanced functionality Powerful API for integration with other web applications See http://www.mathjax.org/ for additional details about MathJax, and https://docs.mathjax.org for the MathJax documentation. MathJax Components MathJax version 3 uses files called components that contain the various MathJax modules that you can include in your web pages or access on a server through NodeJS. Some components combine all the pieces you need to run MathJax with one or more input formats and a particular output format, while other components are pieces that can be loaded on demand when needed, or by a configuration that specifies the pieces you want to combine in a custom way. For usage instructions, see the MathJax documentation . Components provide a convenient packaging of MathJax's modules, but it is possible for you to form your own custom components, or to use MathJax's modules directly in a node application on a server. There are web examples showing how to use MathJax in web pages and how to build your own components, and node examples illustrating how to use components in node applications or call MathJax modules directly. What's in this Repository This repository contains only the component files for MathJax, not the source code for MathJax (which are available in a separate MathJax source repository ). These component files are the ones served by the CDNs that offer MathJax to the web. In version 2, the files used on the web were also the source files for MathJax, but in version 3, the source files are no longer on the CDN, as they are not what are run in the browser. The components are stored in the es5 directory, and are in ES5 format for the widest possible compatibility. In the future, we may make an es6 directory containing ES6 versions of the components. Installation and Use Using MathJax components from a CDN on the web If you are loading MathJax from a CDN into a web page, there is no need to install anything. Simply use a script tag that loads MathJax from the CDN. E.g., <script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script> See the MathJax documentation , the MathJax Web Demos , and the MathJax Component Repository for more information. Hosting your own copy of the MathJax Components If you want to host MathJax from your own server, you can do so by installing the mathjax package using npm and moving the es5 directory to an appropriate location on your server: npm install mathjax@3 mv node_modules/mathjax/es5 <path-to-server-location>/mathjax Note that we are still making updates to version 2, so include @3 when you install, since the latest chronological version may not be version 3. Alternatively, you can get the files via GitHub: git clone https://github.com/mathjax/MathJax.git mj-tmp mv mj-tmp/es5 <path-to-server-location>/mathjax rm -rf mj-tmp Then (in either case) you can use a script tag like the following: <script id=\"MathJax-script\" async src=\"<url-to-your-site>/mathjax/tex-chtml.js\"></script> where <url-to-your-site> is replaced by the URL to the location where you moved the MathJax files above. See the documentation for details. Using MathJax components in a node application To use MathJax components in a node application, install the mathjax package: npm install mathjax@3 (we are still making updates to version 2, so you should include @3 since the latest chronological version may not be version 3). Then require mathjax within your application: require('mathjax').init({ ... }).then((MathJax) => { ... }); where the first { ... } is a MathJax configuration, and the second { ... } is the code to run after MathJax has been loaded. E.g. require('mathjax').init({ loader: {load: ['input/tex', 'output/svg']} }).then((MathJax) => { const svg = MathJax.tex2svg('\\\\frac{1}{x^2-1}', {display: true}); console.log(MathJax.startup.adaptor.outerHTML(svg)); }).catch((err) => console.log(err.message)); Note: this technique is for node-based application only, not for browser applications. This method sets up an alternative DOM implementation, which you don't need in the browser, and tells MathJax to use node's require() command to load external modules. This setup will not work properly in the browser, even if you webpack it or bundle it in other ways. See the documentation and the MathJax Node Repository for more details. Reducing the Size of the Components Directory Since the es5 directory contains all the component files, so if you are only planning one use one configuration, you can reduce the size of the MathJax directory by removing unused components. For example, if you are using the tex-chtml.js component, then you can remove the tex-mml-chtml.js , tex-svg.js , tex-mml-svg.js , tex-chtml-full.js , and tex-svg-full.js configurations, which will save considerable space. Indeed, you should be able to remove everything other than tex-chtml.js , and the input/tex/extensions , output/chtml/fonts/woff-v2 , adaptors , a11y , and sre directories. If you are using the results only on the web, you can remove adaptors as well. If you are not using A11Y support (e.g., speech generation, or semantic enrichment), then you can remove a11y and sre as well (though in this case you may need to disable the assistive tools in the MathJax contextual menu in order to avoid MathJax trying to load them when they aren't there). If you are using SVG rather than CommonHTML output (e.g., tex-svg.js rather than tex-chtml.js ), you can remove the output/chtml/fonts/woff-v2 directory. If you are using MathML input rather than TeX (e.g., mml-chtml.js rather than tex-chtml.js ), then you can remove input/tex/extensions as well. The Component Files and Pull Requests The es5 directory is generated automatically from the contents of the MathJax source repository. You can rebuild the components using the command npm run make-es5 --silent Note that since the contents of this repository are generated automatically, you should not submit pull requests that modify the contents of the es5 directory. If you wish to submit a modification to MathJax, you should make a pull request in the MathJax source repository . MathJax Community The main MathJax website is http://www.mathjax.org , and it includes announcements and other important information. A MathJax user forum for asking questions and getting assistance is hosted at Google, and the MathJax bug tracker is hosted at GitHub. Before reporting a bug, please check that it has not already been reported. Also, please use the bug tracker (rather than the help forum) for reporting bugs, and use the user's forum (rather than the bug tracker) for questions about how to use MathJax. MathJax Resources MathJax Documentation MathJax Components MathJax Source Code MathJax Web Examples MathJax Node Examples MathJax Bug Tracker MathJax Users' Group","title":"MathJax"},{"location":"MathJax/#mathjax","text":"","title":"MathJax"},{"location":"MathJax/#beautiful-math-in-all-browsers","text":"MathJax is an open-source JavaScript display engine for LaTeX, MathML, and AsciiMath notation that works in all modern browsers. It was designed with the goal of consolidating the recent advances in web technologies into a single, definitive, math-on-the-web platform supporting the major browsers and operating systems. It requires no setup on the part of the user (no plugins to download or software to install), so the page author can write web documents that include mathematics and be confident that users will be able to view it naturally and easily. Simply include MathJax and some mathematics in a web page, and MathJax does the rest. Some of the main features of MathJax include: High-quality display of LaTeX, MathML, and AsciiMath notation in HTML pages Supported in most browsers with no plug-ins, extra fonts, or special setup for the reader Easy for authors, flexible for publishers, extensible for developers Supports math accessibility, cut-and-paste interoperability, and other advanced functionality Powerful API for integration with other web applications See http://www.mathjax.org/ for additional details about MathJax, and https://docs.mathjax.org for the MathJax documentation.","title":"Beautiful math in all browsers"},{"location":"MathJax/#mathjax-components","text":"MathJax version 3 uses files called components that contain the various MathJax modules that you can include in your web pages or access on a server through NodeJS. Some components combine all the pieces you need to run MathJax with one or more input formats and a particular output format, while other components are pieces that can be loaded on demand when needed, or by a configuration that specifies the pieces you want to combine in a custom way. For usage instructions, see the MathJax documentation . Components provide a convenient packaging of MathJax's modules, but it is possible for you to form your own custom components, or to use MathJax's modules directly in a node application on a server. There are web examples showing how to use MathJax in web pages and how to build your own components, and node examples illustrating how to use components in node applications or call MathJax modules directly.","title":"MathJax Components"},{"location":"MathJax/#whats-in-this-repository","text":"This repository contains only the component files for MathJax, not the source code for MathJax (which are available in a separate MathJax source repository ). These component files are the ones served by the CDNs that offer MathJax to the web. In version 2, the files used on the web were also the source files for MathJax, but in version 3, the source files are no longer on the CDN, as they are not what are run in the browser. The components are stored in the es5 directory, and are in ES5 format for the widest possible compatibility. In the future, we may make an es6 directory containing ES6 versions of the components.","title":"What's in this Repository"},{"location":"MathJax/#installation-and-use","text":"","title":"Installation and Use"},{"location":"MathJax/#using-mathjax-components-from-a-cdn-on-the-web","text":"If you are loading MathJax from a CDN into a web page, there is no need to install anything. Simply use a script tag that loads MathJax from the CDN. E.g., <script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script> See the MathJax documentation , the MathJax Web Demos , and the MathJax Component Repository for more information.","title":"Using MathJax components from a CDN on the web"},{"location":"MathJax/#hosting-your-own-copy-of-the-mathjax-components","text":"If you want to host MathJax from your own server, you can do so by installing the mathjax package using npm and moving the es5 directory to an appropriate location on your server: npm install mathjax@3 mv node_modules/mathjax/es5 <path-to-server-location>/mathjax Note that we are still making updates to version 2, so include @3 when you install, since the latest chronological version may not be version 3. Alternatively, you can get the files via GitHub: git clone https://github.com/mathjax/MathJax.git mj-tmp mv mj-tmp/es5 <path-to-server-location>/mathjax rm -rf mj-tmp Then (in either case) you can use a script tag like the following: <script id=\"MathJax-script\" async src=\"<url-to-your-site>/mathjax/tex-chtml.js\"></script> where <url-to-your-site> is replaced by the URL to the location where you moved the MathJax files above. See the documentation for details.","title":"Hosting your own copy of the MathJax Components"},{"location":"MathJax/#using-mathjax-components-in-a-node-application","text":"To use MathJax components in a node application, install the mathjax package: npm install mathjax@3 (we are still making updates to version 2, so you should include @3 since the latest chronological version may not be version 3). Then require mathjax within your application: require('mathjax').init({ ... }).then((MathJax) => { ... }); where the first { ... } is a MathJax configuration, and the second { ... } is the code to run after MathJax has been loaded. E.g. require('mathjax').init({ loader: {load: ['input/tex', 'output/svg']} }).then((MathJax) => { const svg = MathJax.tex2svg('\\\\frac{1}{x^2-1}', {display: true}); console.log(MathJax.startup.adaptor.outerHTML(svg)); }).catch((err) => console.log(err.message)); Note: this technique is for node-based application only, not for browser applications. This method sets up an alternative DOM implementation, which you don't need in the browser, and tells MathJax to use node's require() command to load external modules. This setup will not work properly in the browser, even if you webpack it or bundle it in other ways. See the documentation and the MathJax Node Repository for more details.","title":"Using MathJax components in a node application"},{"location":"MathJax/#reducing-the-size-of-the-components-directory","text":"Since the es5 directory contains all the component files, so if you are only planning one use one configuration, you can reduce the size of the MathJax directory by removing unused components. For example, if you are using the tex-chtml.js component, then you can remove the tex-mml-chtml.js , tex-svg.js , tex-mml-svg.js , tex-chtml-full.js , and tex-svg-full.js configurations, which will save considerable space. Indeed, you should be able to remove everything other than tex-chtml.js , and the input/tex/extensions , output/chtml/fonts/woff-v2 , adaptors , a11y , and sre directories. If you are using the results only on the web, you can remove adaptors as well. If you are not using A11Y support (e.g., speech generation, or semantic enrichment), then you can remove a11y and sre as well (though in this case you may need to disable the assistive tools in the MathJax contextual menu in order to avoid MathJax trying to load them when they aren't there). If you are using SVG rather than CommonHTML output (e.g., tex-svg.js rather than tex-chtml.js ), you can remove the output/chtml/fonts/woff-v2 directory. If you are using MathML input rather than TeX (e.g., mml-chtml.js rather than tex-chtml.js ), then you can remove input/tex/extensions as well.","title":"Reducing the Size of the Components Directory"},{"location":"MathJax/#the-component-files-and-pull-requests","text":"The es5 directory is generated automatically from the contents of the MathJax source repository. You can rebuild the components using the command npm run make-es5 --silent Note that since the contents of this repository are generated automatically, you should not submit pull requests that modify the contents of the es5 directory. If you wish to submit a modification to MathJax, you should make a pull request in the MathJax source repository .","title":"The Component Files and Pull Requests"},{"location":"MathJax/#mathjax-community","text":"The main MathJax website is http://www.mathjax.org , and it includes announcements and other important information. A MathJax user forum for asking questions and getting assistance is hosted at Google, and the MathJax bug tracker is hosted at GitHub. Before reporting a bug, please check that it has not already been reported. Also, please use the bug tracker (rather than the help forum) for reporting bugs, and use the user's forum (rather than the bug tracker) for questions about how to use MathJax.","title":"MathJax Community"},{"location":"MathJax/#mathjax-resources","text":"MathJax Documentation MathJax Components MathJax Source Code MathJax Web Examples MathJax Node Examples MathJax Bug Tracker MathJax Users' Group","title":"MathJax Resources"},{"location":"MathJax/CONTRIBUTING/","text":"Contributing to MathJax You are interested in giving us a hand? That's awesome! We've put together some brief guidelines that should help you get started quickly and easily. There are lots and lots of ways to get involved, this document covers: reporting an issue bug reports feature requests change requests working on MathJax core key branches and tags submitting pull requests testing and quality assurance writing documentation translation Conduct Reporting An Issue If you're about to raise an issue because you think you've found a problem with MathJax, or you'd like to make a request for a new feature in the codebase, or any other reason, please read this first. The MathJax issue tracker is the preferred channel for bug reports , feature requests , change requests , and submitting pull requests , but please respect the following restrictions: Please search for existing issues . Help us keep duplicate issues to a minimum by checking to see if someone has already reported your problem or requested your idea. Please do not use the issue tracker for personal support requests (use the MathJax User Group ). Please be civil . Keep the discussion on topic and respect the opinions of others. See also our Conduct Guidelines Bug Reports A bug is a demonstrable problem that is caused by the code in the repository. Good bug reports are extremely helpful \u2014 thank you! Guidelines for bug reports: Use the GitHub issue search \u2014 check if the issue has already been reported. Check if the issue has been fixed \u2014 look for closed issues in the current milestone or try to reproduce it using the latest develop branch. Please note that you will need to compile MathJax and make the components in order to test MathJax from the source repository. Share a live sample of the problem \u2014 without a live page it is usually impossible to debug problems; see also the Bug Report Template below. Isolate the problem \u2014 a live sample is a starting point but if you want to speed things up, create a reduced test case . Be specific about your setup (browser, OS versions, etc). Use services like jsbin , CodePen , or jsFiddle to make collaboration on minimal test cases easier for everyone. Include a screenshot/cast as a last resort \u2014 Is your issue about a layout or design feature or bug that is hard to reproduce or isolate? Then please provide a screenshot or screencast. Tools like LICEcap or SauceLabs allow you to quickly and easily record a screencasts. If you make it an animated gif, you can embed it directly into your GitHub issue. Use the Bug Report Template below or click this link to start creating a bug report with the template automatically. A good bug report shouldn't leave others needing to request more information from you. Be sure to include the details of your environment. Template Example ( click to use ): Short and descriptive example bug report title ### Issue Summary A summary of the issue and the browser/OS environment in which it occurs. If suitable, include the steps required to reproduce the bug. ### Steps to Reproduce 1. This is the first step 2. This is the second step 3. Further steps, etc. Any other information you want to share that is relevant to the issue being reported. Especially, why do you consider this to be a bug? What do you expect to happen instead? ### Technical details: * MathJax Version: 2.3 (latest commit: f3aaf3a2a3e964df2770dc4aaaa9c87ce5f47e2c) * Client OS: Mac OS X 10.8.4 * Browser: Chrome 29.0.1547.57 Feature Requests Feature requests are welcome. Before you submit one, be sure to have: Used the GitHub search to check that the feature hasn't already been requested. Take a moment to think about whether your idea fits with the scope and aims of the project, or if it might better fit being a custom extension . Remember, it's up to you to make a strong case to convince the project's leaders of the merits of this feature. Please provide as much detail and context as possible, this means explaining the use case and why it is likely to be common. Change Requests Change requests cover both architectural and functional changes to how MathJax works. If you have an idea for a new or different dependency, a refactor, or an improvement to a feature, etc., please be sure to: Use the GitHub search to check that someone else didn't get there first. Take a moment to think about the best way to make a case for, and explain what you're thinking. Are you sure this shouldn't really be a bug report or a feature request ? Is it really one idea or is it many? What's the context? What problem are you solving? Why is what you are suggesting better than what's already there? Working on MathJax core You want to contribute code? We describe how below. First, note that the MathJax source code is in the https://github.com/mathjax/MathJax-src repository, not the https://github.com/mathjax/MathJax repository, which contains the packaged component files for distribution on CDNs and the mathjax npm package (the source code is included in the mathjax-full npm package ). Key Branches & Tags MathJax uses several permanent branches in the MathJax source repository : develop is the development branch. All work on the next release happens here so you should generally branch off develop if you are going to submit a pull request. Do NOT use this branch for a production site. master contains the latest release of MathJax. This branch may be used in production. Do NOT use this branch to work on MathJax's source. These branches reflect version 3 of MathJax, which is substantially different from the version 2 codebase. Version 2 will continue to be maintained while web sites transition to version 3, with work being done using the following branches in the MathJax distribution repository : legacy-v2-develop is the development branch for changes to the legacy version 2 code. Any pull requests for version 2 should be branched from here. Do NOT use this branch for a production site. legacy-v2 is the branch that contains any updates to version 2 following the release of version 3. Do NOT use this branch to work on MathJax's source. In addition to these branches, MathJax uses tags to identify the various versions. These can be checked out to obtain the specified release; for example, git checkout 2.7.5 would get you the files for version 2.7.5 of MathJax. Note that version 3 is written in Typescript, and so must be compiled to obtain usable javascript files, and that the components need to be built once that is done. See the documentation for details. For version 2, the source javascript files are not compressed until a release is made, so you should use the copies in the unpacked directory during development. Submitting Pull Requests Pull requests are welcome. If you're looking to submit a PR for something that doesn't have an open issue, please consider raising an issue that your PR can close, especially if you're fixing a bug. This makes it more likely that there will be enough information available for your PR to be properly tested and merged. Need Help? If you're not completely clear on how to submit/update/ do Pull Requests, please check out our source control policies . For more insights, check the excellent in depth Git Workflow guide from Ghost, in particular Ghost Workflow guide: commit messages Testing and Quality Assurance If you're looking to get involved with the code base and don't know where to start, checking out and testing a pull request is one of the most useful things you could do. These are some excellent instructions on configuring your GitHub repository to allow you to checkout pull requests in the same way as branches. Writing documentation MathJax's main documentation can be found at docs.mathjax.org . The source of the docs is hosted in the mathjax/MathJax-docs repo here on GitHub. The documentation is generated using Sphinx-doc and hosted on Read the docs . You can clone the repo and submit pull requests following the pull-request guidelines. Translation If you wish to add or update translations of MathJax, please do it on TranslateWiki.net (and while you're there you can help other open source projects, too). For bug reports and other questions that don't fit on TranslateWiki.net, head over to the mathjax/mathjax-i18n repository. The translation files currently are for version 2, as localization hasn't been added to version 3 yet. Conduct As a NumFOCUS fiscally sponsored project, MathJax is governed by the NumFOCUS code of conduct , which we summarize as follows: We are committed to providing a friendly, safe and welcoming environment for all, regardless of gender, sexual orientation, disability, ethnicity, religion, or similar personal characteristic. Please be kind and courteous. There's no need to be mean or rude. Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer, merely an optimal answer given a set of values and circumstances. Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works. We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behaviour. We interpret the term \"harassment\" as including the definition in the Unacceptable Behavior section of the NumFOCUS code of conduct ; if you have any lack of clarity about what might be included in that concept, please read that definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups. Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the MathJax core team immediately. Whether you're a regular contributor or a newcomer, we care about making this community a safe place for you and we've got your back. Likewise any spamming, trolling, flaming, baiting, or other attention-stealing behaviour is not welcome. We also recommend that you read discourse's rules for further suggestions on appropriate behavior. References We heavily borrowed from Mozilla and Ghost -- thank you! https://github.com/TryGhost/Ghost/blob/master/CONTRIBUTING.md https://github.com/mozilla/rust/wiki/Note-development-policy https://github.com/jden/CONTRIBUTING.md/blob/master/CONTRIBUTING.md http://blog.discourse.org/2013/03/the-universal-rules-of-civilized-discourse/","title":"Contributing to MathJax"},{"location":"MathJax/CONTRIBUTING/#contributing-to-mathjax","text":"You are interested in giving us a hand? That's awesome! We've put together some brief guidelines that should help you get started quickly and easily. There are lots and lots of ways to get involved, this document covers: reporting an issue bug reports feature requests change requests working on MathJax core key branches and tags submitting pull requests testing and quality assurance writing documentation translation Conduct","title":"Contributing to MathJax"},{"location":"MathJax/CONTRIBUTING/#reporting-an-issue","text":"If you're about to raise an issue because you think you've found a problem with MathJax, or you'd like to make a request for a new feature in the codebase, or any other reason, please read this first. The MathJax issue tracker is the preferred channel for bug reports , feature requests , change requests , and submitting pull requests , but please respect the following restrictions: Please search for existing issues . Help us keep duplicate issues to a minimum by checking to see if someone has already reported your problem or requested your idea. Please do not use the issue tracker for personal support requests (use the MathJax User Group ). Please be civil . Keep the discussion on topic and respect the opinions of others. See also our Conduct Guidelines","title":"Reporting An Issue"},{"location":"MathJax/CONTRIBUTING/#bug-reports","text":"A bug is a demonstrable problem that is caused by the code in the repository. Good bug reports are extremely helpful \u2014 thank you! Guidelines for bug reports: Use the GitHub issue search \u2014 check if the issue has already been reported. Check if the issue has been fixed \u2014 look for closed issues in the current milestone or try to reproduce it using the latest develop branch. Please note that you will need to compile MathJax and make the components in order to test MathJax from the source repository. Share a live sample of the problem \u2014 without a live page it is usually impossible to debug problems; see also the Bug Report Template below. Isolate the problem \u2014 a live sample is a starting point but if you want to speed things up, create a reduced test case . Be specific about your setup (browser, OS versions, etc). Use services like jsbin , CodePen , or jsFiddle to make collaboration on minimal test cases easier for everyone. Include a screenshot/cast as a last resort \u2014 Is your issue about a layout or design feature or bug that is hard to reproduce or isolate? Then please provide a screenshot or screencast. Tools like LICEcap or SauceLabs allow you to quickly and easily record a screencasts. If you make it an animated gif, you can embed it directly into your GitHub issue. Use the Bug Report Template below or click this link to start creating a bug report with the template automatically. A good bug report shouldn't leave others needing to request more information from you. Be sure to include the details of your environment. Template Example ( click to use ): Short and descriptive example bug report title ### Issue Summary A summary of the issue and the browser/OS environment in which it occurs. If suitable, include the steps required to reproduce the bug. ### Steps to Reproduce 1. This is the first step 2. This is the second step 3. Further steps, etc. Any other information you want to share that is relevant to the issue being reported. Especially, why do you consider this to be a bug? What do you expect to happen instead? ### Technical details: * MathJax Version: 2.3 (latest commit: f3aaf3a2a3e964df2770dc4aaaa9c87ce5f47e2c) * Client OS: Mac OS X 10.8.4 * Browser: Chrome 29.0.1547.57","title":"Bug Reports"},{"location":"MathJax/CONTRIBUTING/#feature-requests","text":"Feature requests are welcome. Before you submit one, be sure to have: Used the GitHub search to check that the feature hasn't already been requested. Take a moment to think about whether your idea fits with the scope and aims of the project, or if it might better fit being a custom extension . Remember, it's up to you to make a strong case to convince the project's leaders of the merits of this feature. Please provide as much detail and context as possible, this means explaining the use case and why it is likely to be common.","title":"Feature Requests"},{"location":"MathJax/CONTRIBUTING/#change-requests","text":"Change requests cover both architectural and functional changes to how MathJax works. If you have an idea for a new or different dependency, a refactor, or an improvement to a feature, etc., please be sure to: Use the GitHub search to check that someone else didn't get there first. Take a moment to think about the best way to make a case for, and explain what you're thinking. Are you sure this shouldn't really be a bug report or a feature request ? Is it really one idea or is it many? What's the context? What problem are you solving? Why is what you are suggesting better than what's already there?","title":"Change Requests"},{"location":"MathJax/CONTRIBUTING/#working-on-mathjax-core","text":"You want to contribute code? We describe how below. First, note that the MathJax source code is in the https://github.com/mathjax/MathJax-src repository, not the https://github.com/mathjax/MathJax repository, which contains the packaged component files for distribution on CDNs and the mathjax npm package (the source code is included in the mathjax-full npm package ).","title":"Working on MathJax core"},{"location":"MathJax/CONTRIBUTING/#key-branches-tags","text":"MathJax uses several permanent branches in the MathJax source repository : develop is the development branch. All work on the next release happens here so you should generally branch off develop if you are going to submit a pull request. Do NOT use this branch for a production site. master contains the latest release of MathJax. This branch may be used in production. Do NOT use this branch to work on MathJax's source. These branches reflect version 3 of MathJax, which is substantially different from the version 2 codebase. Version 2 will continue to be maintained while web sites transition to version 3, with work being done using the following branches in the MathJax distribution repository : legacy-v2-develop is the development branch for changes to the legacy version 2 code. Any pull requests for version 2 should be branched from here. Do NOT use this branch for a production site. legacy-v2 is the branch that contains any updates to version 2 following the release of version 3. Do NOT use this branch to work on MathJax's source. In addition to these branches, MathJax uses tags to identify the various versions. These can be checked out to obtain the specified release; for example, git checkout 2.7.5 would get you the files for version 2.7.5 of MathJax. Note that version 3 is written in Typescript, and so must be compiled to obtain usable javascript files, and that the components need to be built once that is done. See the documentation for details. For version 2, the source javascript files are not compressed until a release is made, so you should use the copies in the unpacked directory during development.","title":"Key Branches &amp; Tags"},{"location":"MathJax/CONTRIBUTING/#submitting-pull-requests","text":"Pull requests are welcome. If you're looking to submit a PR for something that doesn't have an open issue, please consider raising an issue that your PR can close, especially if you're fixing a bug. This makes it more likely that there will be enough information available for your PR to be properly tested and merged.","title":"Submitting Pull Requests"},{"location":"MathJax/CONTRIBUTING/#need-help","text":"If you're not completely clear on how to submit/update/ do Pull Requests, please check out our source control policies . For more insights, check the excellent in depth Git Workflow guide from Ghost, in particular Ghost Workflow guide: commit messages","title":"Need Help?"},{"location":"MathJax/CONTRIBUTING/#testing-and-quality-assurance","text":"If you're looking to get involved with the code base and don't know where to start, checking out and testing a pull request is one of the most useful things you could do. These are some excellent instructions on configuring your GitHub repository to allow you to checkout pull requests in the same way as branches.","title":"Testing and Quality Assurance"},{"location":"MathJax/CONTRIBUTING/#writing-documentation","text":"MathJax's main documentation can be found at docs.mathjax.org . The source of the docs is hosted in the mathjax/MathJax-docs repo here on GitHub. The documentation is generated using Sphinx-doc and hosted on Read the docs . You can clone the repo and submit pull requests following the pull-request guidelines.","title":"Writing documentation"},{"location":"MathJax/CONTRIBUTING/#translation","text":"If you wish to add or update translations of MathJax, please do it on TranslateWiki.net (and while you're there you can help other open source projects, too). For bug reports and other questions that don't fit on TranslateWiki.net, head over to the mathjax/mathjax-i18n repository. The translation files currently are for version 2, as localization hasn't been added to version 3 yet.","title":"Translation"},{"location":"MathJax/CONTRIBUTING/#conduct","text":"As a NumFOCUS fiscally sponsored project, MathJax is governed by the NumFOCUS code of conduct , which we summarize as follows: We are committed to providing a friendly, safe and welcoming environment for all, regardless of gender, sexual orientation, disability, ethnicity, religion, or similar personal characteristic. Please be kind and courteous. There's no need to be mean or rude. Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer, merely an optimal answer given a set of values and circumstances. Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works. We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behaviour. We interpret the term \"harassment\" as including the definition in the Unacceptable Behavior section of the NumFOCUS code of conduct ; if you have any lack of clarity about what might be included in that concept, please read that definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups. Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the MathJax core team immediately. Whether you're a regular contributor or a newcomer, we care about making this community a safe place for you and we've got your back. Likewise any spamming, trolling, flaming, baiting, or other attention-stealing behaviour is not welcome. We also recommend that you read discourse's rules for further suggestions on appropriate behavior.","title":"Conduct"},{"location":"MathJax/CONTRIBUTING/#references","text":"We heavily borrowed from Mozilla and Ghost -- thank you! https://github.com/TryGhost/Ghost/blob/master/CONTRIBUTING.md https://github.com/mozilla/rust/wiki/Note-development-policy https://github.com/jden/CONTRIBUTING.md/blob/master/CONTRIBUTING.md http://blog.discourse.org/2013/03/the-universal-rules-of-civilized-discourse/","title":"References"},{"location":"computer_concepts/languages/","text":"Compiled Code vs. Interpreted Code It is worth having clear in your mind the differences between two different kinds of program execution. We can think of a program as a set of instructions that manipulate data (in the broadest sense of these words). This manipulation of data can result in displaying videos on your computer or performing complicated physics calculations. Generally speaking, programs can be either compiled or interpreted . An interpreted program is one where lines of code are executed one by one in sequence. An interpreter is responsible for reading a line of code and then executing what it says. Python is probably the most famous example of an interpreted language (though to be fair, I believe Python does have some degree of compiling for the experts in the crowd). They offer incredible flexibility, natively supporting interactive notebooks. They allow for quickly testing pieces of code, and direct access to all intermediate states and stored variables. Typing of variables tends to be dynamic and memory is also dynamically allocated, taken when needed. It is safe to say that interpreted languages like Python are the most user friendly, usually allowing for easy and intuitive setup and debugging. A compiled program is one where ultimately lines of code are executed one by one (as all programs are), but they are not necessarily the exact lines you've written. In a compiled programs, the instructions (code) you write are looked at as a whole and then compiled into a standalone program. Why would one want to do such a thing? What advantages does this bring to the table? Compiled code runs faster : In general, compiled code runs faster! This is because compiled code can be optimized . By knowing all of the code that should be run in the program, compilers use this information to make optimization decisions. For example, if you have code that reads a = 1 a = a + 1 In compiled code, we'd likely find that a was never 1! It was probably optimized to just take the value 2. Good compilers will try to do as much work as possible ahead of time, and deduce as much as possible from your code to make it efficient. In an interpreted language, since it is unknown what will happen after a given line of execution, the a = 1 needs to be executed faithfully. Errors are detected earlier in compiled code : In interpreted code, errors appear when the line in which the error is located is run . Suppose you are running a calculation, but a typo is present at the end when the data is saved. In this case, you need to complete the long calculation before you even realize the typo and can lose a lot of time! This is where I always suggest that when using interpreted/script based codes, before running long calculations, try to run a shorter one just to ensure that there is no error after all the hard work is completed! In compiled code, typos do not make it to the program, since the code cannot compile if it doesn't recognize a variable name, for instance. Another somewhat annoying situation is when you have a branch in the code. The error may exist only in one of the branches, so if all your code utilizes the other one, this error may remain hidden. Once again, in compiled code, one needs to contend with such an error to even compile the program. Seemingly non-repeatable behavior is more likely in interpreted code : One of the simplest, yet true, assumptions of computer programming is that if you run the exact same code multiple times, you should get the exact result every time. After all, as students of physics, this fact should not surprise us! However, based on how strict one is, this principle may be seemingly false. Of course, if we establish the exact same initial conditions down to the atomic level on your computer, then we really ought to expect the same result each time (let's not worry about quantum measurement... or deeper questions about whether physics is deterministic). However, in practical matters, some behavior can actually be non-deterministic (at least from the programmer's perspective). When multiple threads are running on a computer, based on the timing relationships of when threads are run (and especially if they share memory resources), different behavior can arise, depending on the order in which the threads access the memory. Good multithreaded programming should eliminate such non-deterministic behavior, but nonetheless, this serves as an example of when we might expect non-repeatable behavior. The situation is even worse for interpreted code. In interpreted code (say code that you're running in an interactive notebook such as Jupyter), this can arise quite often. The initial conditions are harder to track. Suppose the user has run the cells in a different order, or for debugging purposes, one quickly defines a variable but then deletes the code to clean up. These are all actions that have consequences on the workspace when another cell block is run. These are considerations that require more special attention when using interpreted code. In compiled code, the program is run fresh every time, and the conditions when a particular block of code executes is more predictable. Dynamic code modifications are tricky in interpreted code :","title":"What Language Should I Use?"},{"location":"computer_concepts/languages/#compiled-code-vs-interpreted-code","text":"It is worth having clear in your mind the differences between two different kinds of program execution. We can think of a program as a set of instructions that manipulate data (in the broadest sense of these words). This manipulation of data can result in displaying videos on your computer or performing complicated physics calculations. Generally speaking, programs can be either compiled or interpreted . An interpreted program is one where lines of code are executed one by one in sequence. An interpreter is responsible for reading a line of code and then executing what it says. Python is probably the most famous example of an interpreted language (though to be fair, I believe Python does have some degree of compiling for the experts in the crowd). They offer incredible flexibility, natively supporting interactive notebooks. They allow for quickly testing pieces of code, and direct access to all intermediate states and stored variables. Typing of variables tends to be dynamic and memory is also dynamically allocated, taken when needed. It is safe to say that interpreted languages like Python are the most user friendly, usually allowing for easy and intuitive setup and debugging. A compiled program is one where ultimately lines of code are executed one by one (as all programs are), but they are not necessarily the exact lines you've written. In a compiled programs, the instructions (code) you write are looked at as a whole and then compiled into a standalone program. Why would one want to do such a thing? What advantages does this bring to the table? Compiled code runs faster : In general, compiled code runs faster! This is because compiled code can be optimized . By knowing all of the code that should be run in the program, compilers use this information to make optimization decisions. For example, if you have code that reads a = 1 a = a + 1 In compiled code, we'd likely find that a was never 1! It was probably optimized to just take the value 2. Good compilers will try to do as much work as possible ahead of time, and deduce as much as possible from your code to make it efficient. In an interpreted language, since it is unknown what will happen after a given line of execution, the a = 1 needs to be executed faithfully. Errors are detected earlier in compiled code : In interpreted code, errors appear when the line in which the error is located is run . Suppose you are running a calculation, but a typo is present at the end when the data is saved. In this case, you need to complete the long calculation before you even realize the typo and can lose a lot of time! This is where I always suggest that when using interpreted/script based codes, before running long calculations, try to run a shorter one just to ensure that there is no error after all the hard work is completed! In compiled code, typos do not make it to the program, since the code cannot compile if it doesn't recognize a variable name, for instance. Another somewhat annoying situation is when you have a branch in the code. The error may exist only in one of the branches, so if all your code utilizes the other one, this error may remain hidden. Once again, in compiled code, one needs to contend with such an error to even compile the program. Seemingly non-repeatable behavior is more likely in interpreted code : One of the simplest, yet true, assumptions of computer programming is that if you run the exact same code multiple times, you should get the exact result every time. After all, as students of physics, this fact should not surprise us! However, based on how strict one is, this principle may be seemingly false. Of course, if we establish the exact same initial conditions down to the atomic level on your computer, then we really ought to expect the same result each time (let's not worry about quantum measurement... or deeper questions about whether physics is deterministic). However, in practical matters, some behavior can actually be non-deterministic (at least from the programmer's perspective). When multiple threads are running on a computer, based on the timing relationships of when threads are run (and especially if they share memory resources), different behavior can arise, depending on the order in which the threads access the memory. Good multithreaded programming should eliminate such non-deterministic behavior, but nonetheless, this serves as an example of when we might expect non-repeatable behavior. The situation is even worse for interpreted code. In interpreted code (say code that you're running in an interactive notebook such as Jupyter), this can arise quite often. The initial conditions are harder to track. Suppose the user has run the cells in a different order, or for debugging purposes, one quickly defines a variable but then deletes the code to clean up. These are all actions that have consequences on the workspace when another cell block is run. These are considerations that require more special attention when using interpreted code. In compiled code, the program is run fresh every time, and the conditions when a particular block of code executes is more predictable. Dynamic code modifications are tricky in interpreted code :","title":"Compiled Code vs. Interpreted Code"},{"location":"computer_concepts/networking/","text":"Computer networking is a vast subject that is probably covered in many courses to a much greater extent than here. Nevertheless, it is helpful to be aware of some basics that can affect how you think about things in the lab or when you work with our lab's routers. In the most general sense, packets of information need to be sent out, and then subsequently replied to. We will need a more detailed discussion for the content and protocol being used for these packages. Let's start with how packages are routed to the right place. The Internet and IP Addresses The Internet Corporation for Assigned Names and Numbers (ICANN) regulates the address locations of servers around the world. In particular, servers are identified by a unique address (called a IP address) of the format XXX.XXX.XXX.XXX , where XXX is an integer number from 0 to 255. Hence, there are 256^4 = 4294967296 256^4 = 4294967296 unique addresses or about 4 billion addresses. test","title":"Networking"},{"location":"computer_concepts/networking/#the-internet-and-ip-addresses","text":"The Internet Corporation for Assigned Names and Numbers (ICANN) regulates the address locations of servers around the world. In particular, servers are identified by a unique address (called a IP address) of the format XXX.XXX.XXX.XXX , where XXX is an integer number from 0 to 255. Hence, there are 256^4 = 4294967296 256^4 = 4294967296 unique addresses or about 4 billion addresses. test","title":"The Internet and IP Addresses"},{"location":"computer_concepts/system_management/","text":"A Primer on Computer Systems A basic understanding of computer systems and how they work is essential to understanding how our codebase works together in concert and helps debug a multitude of problems when setting up a new computer or control system. It also helps to understand how to add new features to our system. The resources on this are quite scattered and often include too much information or not the right information. Here, we try to distill the key things that will help debug and understand how code talks to each other and is executed. We will approach this issue from a very physics-like perspective and try to understand how \"contact\" is made between different pieces of code, and how a causal chain of events result from every execution of code.","title":"Computer Systems"},{"location":"computer_concepts/system_management/#a-primer-on-computer-systems","text":"A basic understanding of computer systems and how they work is essential to understanding how our codebase works together in concert and helps debug a multitude of problems when setting up a new computer or control system. It also helps to understand how to add new features to our system. The resources on this are quite scattered and often include too much information or not the right information. Here, we try to distill the key things that will help debug and understand how code talks to each other and is executed. We will approach this issue from a very physics-like perspective and try to understand how \"contact\" is made between different pieces of code, and how a causal chain of events result from every execution of code.","title":"A Primer on Computer Systems"},{"location":"software/overview/","text":"Software Overview There are many different pieces of software that come together to run all pieces of the computer control system. We first provide an overview of what are all the pieces of software that are needed and list the repositories that one needs to access to acquire and review the source code. We go from the top-down for this overview. MATLAB Frontend : The frontend is written in MATLAB and predominantly lives in two repositories. The shared code that is in principle usable by all experiments is located in the repository libnacs-matlab . This shared code is a submodule for the main experimental control frontend code that is located in the repository experiment-control . Note that the shared code is hosted by github , while the actual experimental control code that contains the sequences and scans we run is hosted by gitlab on the private server of former graduate student Yichao Yu. Python interface to libnacs : The MATLAB primary communicates with our compiled C++ code via the Python repository python-libnacs . The code in this repository is rather limited and mainly wraps the functions that are exposed from the C++ layer. ; C++ library codebase : The C++ codebase is known as libnacs , and contains nearly all the C++ code on our experiment. This means it is used in multiple locations and serves many functions. On the experimental computer side, libnacs contains functions to compile a sequence as well as device-specific classes that are responsible for executing the sequence from the experimental computer side. These are client classes that ultimately send commands across a network. It also contains many utilities like functions covering memory and system management to networking tools, so it is also a helper library for other repositories including nacs-spcm and molecube . FPGA server : The server code that runs on the FPGA is known as molecube . Molecube is a server so it responds to requests sent over a network either to provide simple pieces of information (such as the current status of the DDS and TTL channels) or it will run sequences on demand. Molecube communicates with the FPGA via reading and writing to a special memory address specified in the hardware configuration. This read and write occurs through the knacs kernel driver. FPGA kernel driver : The FPGA kernel driver handles the interface between the software running on the FPGA ( molecube ) and the hardware, which has been configured according to the source code in molecube-hw . The kernel driver has simple code to memory map the address of the main AXI bus used to communicate with the hardware. FPGA hardware \"code\" : The source FPGA hardware code, mostly written in SystemVerilog, is located in molecube-hw . This code needs to be synthesized and implemented in Vivado, where the final product is a hardware configuration bit file. This hardware code is responsible for implementing commands with FPGA clock-cycle precision timing. These commands are responsible for programming the Analog Devices DDS chips and for adjusting the TTL outputs. AWG server code : The AWG card is a PCIe card which is hosted on a separate computer. The AWG code located in nacs-spcm contains a server which can respond to client requests such as running a sequence. It also contains code that interfaces with the Spectrum Instrumentation provided kernel driver to produce physical output on the card.","title":"Overview"},{"location":"software/overview/#software-overview","text":"There are many different pieces of software that come together to run all pieces of the computer control system. We first provide an overview of what are all the pieces of software that are needed and list the repositories that one needs to access to acquire and review the source code. We go from the top-down for this overview. MATLAB Frontend : The frontend is written in MATLAB and predominantly lives in two repositories. The shared code that is in principle usable by all experiments is located in the repository libnacs-matlab . This shared code is a submodule for the main experimental control frontend code that is located in the repository experiment-control . Note that the shared code is hosted by github , while the actual experimental control code that contains the sequences and scans we run is hosted by gitlab on the private server of former graduate student Yichao Yu. Python interface to libnacs : The MATLAB primary communicates with our compiled C++ code via the Python repository python-libnacs . The code in this repository is rather limited and mainly wraps the functions that are exposed from the C++ layer. ; C++ library codebase : The C++ codebase is known as libnacs , and contains nearly all the C++ code on our experiment. This means it is used in multiple locations and serves many functions. On the experimental computer side, libnacs contains functions to compile a sequence as well as device-specific classes that are responsible for executing the sequence from the experimental computer side. These are client classes that ultimately send commands across a network. It also contains many utilities like functions covering memory and system management to networking tools, so it is also a helper library for other repositories including nacs-spcm and molecube . FPGA server : The server code that runs on the FPGA is known as molecube . Molecube is a server so it responds to requests sent over a network either to provide simple pieces of information (such as the current status of the DDS and TTL channels) or it will run sequences on demand. Molecube communicates with the FPGA via reading and writing to a special memory address specified in the hardware configuration. This read and write occurs through the knacs kernel driver. FPGA kernel driver : The FPGA kernel driver handles the interface between the software running on the FPGA ( molecube ) and the hardware, which has been configured according to the source code in molecube-hw . The kernel driver has simple code to memory map the address of the main AXI bus used to communicate with the hardware. FPGA hardware \"code\" : The source FPGA hardware code, mostly written in SystemVerilog, is located in molecube-hw . This code needs to be synthesized and implemented in Vivado, where the final product is a hardware configuration bit file. This hardware code is responsible for implementing commands with FPGA clock-cycle precision timing. These commands are responsible for programming the Analog Devices DDS chips and for adjusting the TTL outputs. AWG server code : The AWG card is a PCIe card which is hosted on a separate computer. The AWG code located in nacs-spcm contains a server which can respond to client requests such as running a sequence. It also contains code that interfaces with the Spectrum Instrumentation provided kernel driver to produce physical output on the card.","title":"Software Overview"}]}